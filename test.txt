0046f05b        rot_matrix_to_quaternion(&quaternion, rot_matrix);
0046f060        int32_t quatX = quaternion.x;
0046f06d        int32_t quatY = quaternion.y;
0046f079        int128_t current_abs = _mm_and_ps(quatX, 0x7fffffff);
0046f07c        int128_t absY = _mm_and_ps(quatY, 0x7fffffff);
0046f082        int32_t largest_component;
0046f082        struct Vector calc_vec;
0046f082        int128_t largest_abs;
0046f082        
0046f082        if (absY > current_abs)
0046f082        {
0046f184            largest_component = 1;
0046f189            largest_abs = (double)absY;
0046f082        }
0046f082        else
0046f082        {
0046f08c            largest_component = 0;
0046f08e            calc_vec.x = (double)current_abs;
0046f092            largest_abs = calc_vec.x;
0046f092            *(uint32_t*)((char*)largest_abs)[4] = calc_vec.y;
0046f092            *(uint32_t*)((char*)largest_abs)[8] = calc_vec.z;
0046f082        }
0046f082        
0046f096        calc_vec.x = quaternion.z;
0046f096        calc_vec.y = quaternion.z;
0046f09c        current_abs = calc_vec.x;
0046f09c        *(uint32_t*)((char*)current_abs)[4] = calc_vec.y;
0046f09c        *(uint32_t*)((char*)current_abs)[8] = calc_vec.z;
0046f0a2        current_abs = (double)_mm_and_ps(current_abs, 0x7fffffff);
0046f0a2        
0046f0aa        if (current_abs > largest_abs)
0046f198            largest_component = 2;
0046f0aa        else
0046f0b0            current_abs = largest_abs;
0046f0b0        
0046f0b4        absY = quaternion.w;
0046f0b4        
0046f0ce        if ((double)_mm_and_ps(0x7fffffff, absY) > current_abs)
0046f0ce            largest_component = 3;



int absX = abs(quatX);
int absY = abs(quatY);
int largest = 0;
int largestABS = 0;

if absY > absX {
    largest = 1;
    largestABS = absY;
} else {
    largest = 0;
    largestABS = absX;
}

absZ = abs(quatZ);

if absZ > largestABS {
    largest = 2
}

if abs(quatW) > absZ {
    largest = 3
}